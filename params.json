{
  "name": "Angular.js - Project Architecture. Part I",
  "tagline": "",
  "body": "---\r\n\r\n> This practical guide will help you avoid mistakes in construction of building complex architecture and more readable code.\r\n\r\n> Here you can find the often used tricks, which compliance certainly would help you in real projects.\r\n\r\n> Document is periodically updated, so you can always read and download the latest version here:  https://github.com/asduser/angularjs-recipes.\r\n\r\n> Made by @asduser - https://github.com/asduser.\r\n\r\n#### Download in PDF\r\n\r\nhttps://github.com/asduser/angularjs-recipes/blob/master/Angular_ViewingAround.pdf\r\n\r\n---\r\n\r\n## 1. Decrease the HTML confusion.\r\n\r\n**Description:**\r\n\r\nAs you know, HTML is a hypertext markup language, not a programming and not a some application logical core. It was invented to solve an issues of UI representation.\r\n\r\nBut with the release the Angular.js, many beginner developers have written a lot of critical logic inside html-blocks. Why it can be dangerous?\r\n\r\n1. You can't to debug that code properly. Variables, expressions, functional methods and the sets of data - all of that may be ignored in debugger mode. \r\n2. Each new JavaScript code inside HTML significantly makes worse the common code readability. Over time you will find it difficult to support that \"view\". \r\n3. In most cases this approach prevents the code reuse, because each block has been closely related with a corresponding application logic. \r\n\r\n**Solution:**\r\n\r\nTry decrease the javascript uses inside html blocks. Do it so often as you can. It may cause some discomfort (you have to take care about application architecture), but after a time you reach a success.\r\n\r\n## 2. Dont forget about ng-include.\r\n\r\nAngular.js provides a powerful methodology of using html-templates and ignoring them - a real offence. If html page has a lot of code, the good practice is a dividing it to the smaller functional views. As a consequence, code editing will be a much easier and readable.\r\n\r\n```html\r\n\r\n<!-- Instead of: -->\r\n\r\n<div id=\"tabs\">\r\n  <div id=\"tab-1\"> ... </div>\r\n  <div id=\"tab-2\"> ... </div>\r\n</div>\r\n\r\n<!-- Use: -->\r\n\r\n<div id=\"tabs\">\r\n  <div ng-include=\" 'tabs/my-tab1.html' \"> ... </div>\r\n  <div ng-include=\" 'tabs/my-tab2.html' \"> ... </div>\r\n</div>\r\n\r\n```\r\n\r\nNow, to make changes enough modify *my-tab1.html* or *my-tab2.html* which are located in appropriate directory.    \r\n\r\n\r\n## 3. Explicit named variables.\r\n\r\nDont try mislead your teammates or another developers, who will support you code, they have enough problems. On the contrary, help them to read each line of code like a sentences of adventure book.\r\n\r\nFor example:\r\n```html\r\n<!-- #1 -->\r\n<div ng-hide=\"!isVisible\" class=\"container\"></div>\r\n\r\n<!-- #2 -->\r\n<div ng-show=\"isVisible\" class=\"container\"></div>\r\n\r\n```\r\n\r\nAt the second example you clearly understand what does the code. First example provides you a logic of double negation. It's so easy sample, but the each complication in code will make understanding more difficult (e.g ternary operator with a multiple sequence).\r\n\r\n## 4. Project architecture.\r\n\r\nThere are a lot of different cases how to develop an internal application levels, but I would like to share you my own solution which allows to create a flexible and scalable structure in the future.\r\n\r\n![Image](https://github.com/asduser/angularjs-recepies/blob/master/image1.png?raw=true)\r\n\r\nIn app.js declare the common modules, dependencies and the master module. It's looks like this:\r\n\r\n```javascript\r\n\r\nangular.module(\"app\", [\r\n  \r\n  \"app.constant\",\r\n  \"app.filters\",\r\n  \"app.helpers\",\r\n  \"app.modals\",\r\n  \"_webApi_\",    \r\n  \"app.utils\",\r\n  \r\n  // another dependencies\r\n\r\n]);\r\n\r\n```\r\n \r\nNow let's talk about project architecture above. First of all, a main module was declared that means all another components have to be injected into it.\r\n\r\nThere is a naming methodology for native application modules such as \"filters, helpers, utils\" etc. According to this principle we certainly prevent the presence of suspicious or undesirable components in project.\r\n \r\nExplanation:\r\n\r\n\r\n* **Constant**: contains all static variables for the common entities.\r\n* **Controllers**: project controllers store with 2-level nesting, for example: *controllers -> login -> LoginController.js*, *controllers -> login -> ForgotPasswordController.js*.\r\n* **Css**: styles for different .html representation. \r\n* **Directives**: angular.js directives store with 2-level nesting, for example -> *directives -> form-validator -> formValidator.js*.\r\n* **Filters**: set of filters.\r\n* **Helpers**: a special components to work with controllers (see below).\r\n* **Translations**: different languages for the current application.\r\n* **Images**: graphic objects, .svg, .gif etc.\r\n* **Lib**: external libraries (see below).\r\n* **Modals**: interactive user windows to expose some additional functionality.\r\n* **Repositories**: internal entities to interact with webApi component.\r\n* **Settings**: project configuration file (.js).\r\n* **Utils**: set of specific services, factories which are independent from the current project structure and may bi included into another project.\r\n* **Views**: .html views. Desirable to use an analogical level nesting which is described in controllers directory. For example: we have *controller -> food -> FoodController*. So, a good solution is creating a directory *views -> food -> main.html*, where will be displayed all existing items. To add a new .html page, which is responsible for some Food actions, just add it *into views -> food -> editFood.html*. \r\n* **webApi**: $http requests manager.\r\n\r\nYou may be sure you will save a lot of time and there is no need for finding a concrete method not knowing where the parent file is exactly located.\r\n\r\n## 5. Designation Components.\r\n\r\nIt is a good approach to use the single modules for each functional set of entities due to code modularity, structuration, a single component responsibility.\r\n\r\nAs for declaring component dependencies, so I recommend you work with \"IoC container\" like this:\r\n\r\n```javascript\r\n\r\n// Module.js file in repositories directory.\r\nangular\r\n  .module(\"app.repositories\", []);\r\n  \r\n// Some repository is here.  \r\nangular\r\n  .module(\"app.repositories\")\r\n  .factory(\"repositories.Food\", foodRepository);\r\n  \r\nfunction foodRepository(appSettings){\r\n\r\n  // logic is here...  \r\n\r\n}\r\n\r\n// IoC container.\r\nfoodRepository.$inject = [\r\n  \"constant.APP_SETTINGS\"\r\n];\r\n\r\n```\r\n\r\n\"IoC container\" is responsible for external dependencies, functional components and another entities inside a current item.  \r\n\r\n## 6. Use filters.\r\n\r\nIf your application uses a lot of different conversions, expression, values translation or smth else - just use a filters. It makes your code clearly, shorter and easy to support. Any time a specific block of code could be changed, modified or absolutely replaced by another logic.\r\n\r\n```html \r\n           \r\n<div ng-app=\"myApp\">\r\n\r\n<div ng-controller=\"MyCtrl\">\r\n  <ul>\r\n  <li ng-repeat=\"u in users\"> {{ u | userinfo }} \r\n  </ul>\r\n</div>\r\n\r\n</div>\r\n\r\n```\r\n\r\n```javascript\r\n\r\nvar myApp = angular.module('myApp',[]);\r\n\r\nmyApp.controller(\"MyCtrl\", function($scope){\r\n\r\n$scope.users = [\r\n\t{name: \"Bob\", age: 20},\r\n  {name: \"John\", age: 25}\r\n];\r\n\r\n});\r\n\r\nmyApp.filter(\"userinfo\", function(){\r\n\treturn function(item) {\r\n  \treturn \"My name is \" + item.name + \". I am \" + item.age;\r\n  }\r\n});\r\n\r\n```\r\n\r\n**Result is:**\r\n\r\n```html\r\nMy name is Bob. I am 20\r\nMy name is John. I am 25 \r\n```\r\n\r\n## 7. Controller logic division.\r\n\r\nController is your place where you may manage your data, invoke an appropriate methods and use different factories, services etc. One of the benefits of using multiple controllers is a lack of code duplication. Each repeating block of logic recommended to transfer into a suitable entity.\r\n\r\n```javascript\r\n  angular\r\n    .module(\"app\")\r\n    .service(\"dateConverter\", function(){\r\n      // some code...\r\n    });\r\n``` \r\n  \r\nYou have to think out your further actions immediately before creating a new service or factory, because there are independent controls, which may be injected into a special controller to manage the data. Each service or factory responds only for one goal. That principle helps to create more powerful and scalable entities.\r\n\r\n```javascript\r\n// Example #1\r\n\r\napp.controller(\"UserController\",  [\"$scope\", \"imageService\", \r\n  function($scope, imageService){\r\n\r\n    // ....\r\n    \r\n    $scope.getAvatar = function(url){\r\n      return imageService.get(url); \r\n    };\r\n    \r\n    // Returns default image url.\r\n    var image1 = $scope.getAvatar(null);\r\n\r\n  }]);\r\n  \r\n```\r\n\r\nWe dont need the details what the imageService does, which actions and operations are exist there. You have to understand a one thing - the imageService will return a valid link or default image url (which is determined by a constant type).\r\n\r\nBut dont rush to write a code and clone a bunch of services, which won't be a unique entity or responds only for one JavaScript method. Service or factory is a set of methods, which have a similar behaviour and exist as a different plain levels of big complicated task.\r\n\r\n## 8. Controller naming.\r\n\r\nTry use postfix Controller instead a famous Ctrl. It does titles more readable and looks like a completed word.\r\n\r\n```javascript\r\n\r\napp.controller(\"PlayerController\", [\"$scope\", function($scope){\r\n\r\n//some code ...\r\n\r\n}]\r\n\r\n```\r\n\r\n## 9. Helpers.\r\n\r\n**Description:**\r\n\r\nIf two or more controllers have a resembling blocks of code, methods here is a solution: create a service\\factory which performs within itself all of that logic. Helpers aren't like a utils, services a factories like you used to see them. There are a special entities, which implement only a specific set of methods for one or more controllers.\r\n\r\nFor example, here is a FoodController where user may order food, see the current food directory, rank them or just browse a chemical composition of famous items.\r\n\r\nQuite possibly will be the case when it will be necessary to covnert one value into another (ex. *kilograms* (kg) to *pounds* (lb), *liters* (l) to *milliliters* (mL) etc.). Create a single factory or service isn't a best decision, because service is responsible for a specific functionality and may be injected into another Angular.js entity.\r\n \r\nWhat do you think, is it up to our expectations? There are a several disadvantages of using such services:\r\n\r\n1. The service will be very common and has a lot of unnecessary functions. \r\n2. Inability division of existing functionality into single entities, because there are a lot of codependent JavaScript blocks. \r\n3. With increasing the size of application will increase the number of methods. \r\n\r\n**Solution:**\r\n\r\nCreate a single service\\factory which will depend on a specific controller(s), but implement some logic inside without duplicating throughout the application.\r\n\r\n```javascript\r\n\r\napp.service(\"foodConversionService\", function(){\r\n\r\n//some conversion methods...\r\n\r\n});\r\n\r\n```\r\n\r\nAnd here is a good place to work with weight transformation, changing the liquid values and other physical and chemical food properties.\r\n\r\n## 10. Useful directives.\r\n\r\nOften we need to pass some data into a specific entity to gain a some functional html-code. And here is a solution - Angular.js directives. But remember, each component consumes a certain amount operating memory, moreover it exponentially loads the browser.\r\n\r\nThere is a reason why we need to use a directives deliberately. Use derectives only for use - it's a main mistake of beginners Angular.js developers, cause in many times we can do the usual template without a specific logic and postrenderring.\r\n\r\n* Think twice, before you'll use some component. \r\n* Use directives in places repetition code blocks. \r\n* Be careful when you work with graphic elements, try simplify an existing code as much as it possible. \r\n\r\n## 11. Constants.\r\n\r\nFor a qualitative interation a several components we may take care about the process of data representation. Don't forget that a truly scalable application shouldn't depend on the variables. As a result, use a special Angular.js component - constant.\r\n\r\n```javascript\r\n\r\napp.constant(\"userDetails\", {\r\n    \r\n    \"GENDER\": {\r\n      \"0\": \"Female\",\r\n      \"1\": \"Male\"\r\n    },\r\n    \r\n    \"MIN_AGE\": 18\r\n   \r\n});\r\n\r\n```\r\n\r\nHere we can see a special *\"userDetails\"* constant, which contains the additional information about our application visitors. To add a new property or modify an existing - just enough to change it in one location, there is no need search for it throughout the whole application.\r\n\r\nA good practive to use constants for the complicated block of logic, repeating methods, codependent components etc.\r\n\r\nInitial application settings, options for different components should be included into suitable constant files too. It prevents a code duplication and significantly simplifies an ability to support current application in the future.\r\n\r\n```javascript\r\n\r\napp.constant(\"APP_SETTINGS\", {\r\n    \r\n    \"START_PAGE\": \"app.dashboard\",\r\n    \"REDIRECT_UNAUTHORIZED\": \"app.login\",\r\n    // another variables ...\r\n\r\n});\r\n\r\n```\r\n\r\nThereafter quite enough refer to the existing constant variable from code for calling some action. For example:\r\n\r\n```javascript\r\n\r\nif (user.role != \"Anonymous\") {\r\n  $state.go(APP_SETTINGS.START_PAGE);\r\n} else {\r\n  $state.go(APP_SETTINGS.REDIRECT_UNAUTHORIZED);\r\n}                                   \r\n\r\n```\r\n\r\nThe process of variable value changing includes:\r\n\r\n1. Openning a specific constant file. \r\n2. Setting a new value to variable. \r\n\r\nThere is no need to find all existing variables within application, which significantly saves the time and simplifies a common work.\r\n\r\nBetter to spend more time thinking about the additional constant type, than have only wasting time to find and fix values in the future.\r\n\r\n\r\n## 12. Utils.\r\n\r\n**Description:**\r\n\r\nAs mentioned above, the repeating code should be involved into a service\\factory to it reusing. It a good practice create such a functional modules, which may be transferred into another project without any difficulties.\r\n\r\nSupposably, there is a service to wrk with dates: create, filter, convert into appropriate formats, use a special mask etc. But here is a one often repeated question - some block of our service depends on the current application structure.\r\n\r\n```javascript\r\n\r\napp.service(\"dateManager\", [\"constant.countries\", \"someFactory\", function(countries, someFactory){\r\n\r\n// Don't do this inside a service!\r\n$(\"#some-field\").datepicker();\r\n\r\n// some code...\r\n\r\n}]);\r\n\r\n```\r\n\r\nStatic jQuery #id handling, using another modules o factories to exapose some additional functionality, injection of constant files and many other reasons due to which the service cann't be called a \"reusable\".\r\n\r\n**Solution:**\r\n\r\nTo solve that issue try modify an existing service as much as it possible:\r\n\r\n* Get rid of extra dependencies. \r\n* No need to use an internal constant files inside a \"utils services\\factories\". \r\n* Don't use the static jQuery element handling. \r\n\r\nBut there are cases where the use of additional files to ensure correct operation of the module is necessary. Anyway, try make \"utils\" service universal.\r\n\r\n## 13. Libraries.\r\n\r\nExternal libraries, modules and minified files should be located into a special application directory - lib. There are only libraries, which are not associated with our app.\r\n\r\n*For example:* jQuery, D3.js, Angular.js etc.\r\n\r\n## 14. Modals.\r\n\r\nOften a modern Angular.js applications use modal windows for user interaction, which is especially useful when exist a lot of different dynamic interfaces. *For example:* content filters, confirmations, alerts, run-time installers etc.\r\n\r\nTo simplify the main logic and prevent code duplication inside each of that modal window, include a special \"ModalManager\" where exist a common functional methods.\r\n\r\n```javascript\r\n\r\n// here is some actions within ModalManager controller.\r\n\r\n$scope.openFoodDetailsModal = function(size) {\r\n\r\n    var modalInstance = $modal.open({\r\n        templateUrl: 'source to .html',\r\n        controller: 'FoodDetailsController',\r\n        size: size,\r\n        resolve: {\r\n            numberCollection: function () {\r\n                return [1, 2, 3, 4, 5];\r\n            }\r\n        }\r\n    });\r\n\r\n    modalInstance.result.then(function (response) {\r\n        // some actions with response...\r\n    });\r\n\r\n};\r\n\r\n```\r\n\r\nAs you see, we used a special component to manage our modals. At this point it doesn't matter, but it is important to understand how controllers may interact between themselves.\r\n\r\n*\"openFoodDetailsModal\"* method render a new window, which will retrieve specified *\"FoodDetailsController\"* and some data when it initializes. The last one contains in \"resolve\" field and it is a plain object, each field of which is a specific data type.\r\n\r\nTo inject more different values enough add a new files, ex.:\r\n\r\n```javascript\r\n\r\nresolve: {\r\n            numberCollection: function () {\r\n                return [1, 2, 3, 4, 5];\r\n            },\r\n            user: $scope.currentUser\r\n        }\r\n\r\n```\r\n\r\nMoreover, you may transmit into it a current controller variables, collections, methods or even $rootScope parameters. Each new dependency injection passes throughout ModalManager and there is no need declare many different controllers, services only for delivering some data into specific modal windows.\r\n\r\n## 15. Application Settings.\r\n\r\nA lot of Angular.js project have internal data, which declares in many places, complicating the support and modules expansion. It is not just about common constant files (gender, countries, colors). For example, we have an application \"TITLE\" parameter.\r\n\r\n```javascript\r\n\r\napp.constant(\"APP_SETTINGS\", {\r\n\r\n  \"TITLE\": \"Food Recepies\"\r\n\r\n});\r\n\r\n```\r\n\r\nInject that constant in controller, service, factory is very simple and trivial task, but what about variables definition for using them within html-code? Try do this:\r\n\r\n1. Include *\"APP_SETTINGS\"* constant into $rootScope controller. \r\n2. Declare a suitable variable, which will describe internal application settings like this: $rootScope.appConfig = \"APP_SETTINGS\". \r\n\r\nAnd declare it inside \"Header\", \"Login Page\" and \"Forgot Password Page\":\r\n\r\n```html\r\n\r\n<span> {{ appConfig.TITLE }} </span>\r\n\r\n```\r\n\r\nNow we may change the title without any worrying. Furthermore, each new developer who will work with your code, dont need where is exactly uses that parameter, he have to know just a location for \"APP_SETTINGS\" constant. Usually, it is a directory \"settigns\" in main \"app\" folder.\r\n\r\n## 16. webApi module.\r\n\r\nNowadays virtually all Angular.js project have a close relationship with server-side to manage the data. Authorization, getting some data for tables creating, update something or even administrate mobile apps - all of this depend on a stable and well thought out functionality.\r\n\r\nIt should be a clear division of logic for web Api module, because some block would be changing very often in the early stages of development, but another - not. \r\n\r\nUnlikely we need often change the basic types of database queries ($http.put, $http.get, $http.post, $http.delete etc.), thus all of these components should be located into a \"core\" module. It rarely changes, because the fundamental logic described there and it is no need to make changes every time when you add a new http-request.\r\n\r\nAt the section *\"Useful links\"* you can **read and download** the RESTful webApi module with settings, core functionality, a set of special query formatters and filters.\r\n\r\n**Notice:** webApi module shouldn't know about your internal data, relationships or smth else, because it has been included only for sending queries to server-side and getting an appropriate responses. It is a really big trouble when somebody declares $http methods inside controllers and specifies a lot of data there.\r\n\r\n## 17. Repositories.\r\n\r\nIn continuation of the previous paragraph, now we'll talk about entities which handle $http requests and do some actions after successful or failure response. But, this components don't know nothing about internal data too.\r\n\r\nRepository is responsible for:\r\n\r\n* Sending http-requests with specified params. \r\n* Implementation response functionality and notify controller. \r\n* Manage all internal error requests and different exceptions. \r\n\r\n```javascript\r\n\r\n// repository declaration above...\r\nfunction getAll(){\r\n  return webApi.getAllFoodItems();\r\n}\r\n\r\n```\r\n\r\nIn this example showed how repository may interact with webApi module without any data or logic disclosing. This approach helps to save the components encapsulation and allows to work at the higher abstraction level.\r\n\r\nRecommended to use in repositories for methods without returning a flexible exception handlers, which certainly allow code much easier to read.\r\n\r\n```javascript\r\n\r\nfunction update(id){\r\n  webApi.updateFoodById({\r\n    \"url\": { \"id\": id } \r\n  }).success(function(response){\r\n    checkResponse(response, \"Updated!\");\r\n  });\r\n}\r\n\r\n// Exception handler.\r\nfunction checkResponse(response, message) {\r\n  if (response && response.data) {\r\n    // Case #1\r\n    // Example: alert(message);\r\n  } else {\r\n    // Case #2\r\n    // Example: display default message with text from response or constant file.\r\n  }\r\n}\r\n\r\n```\r\n\r\n**Explanation:** \r\n\r\n1. In first case enough to manage an existing response and show on UI a specific message. It doesn't matter which service obtains and  processes a derived message at the moment.\r\n2. In next one we have to write some logic for catching the exceptions and show information from internal constant file if necessary. \r\n\r\nTo improve an existing code and implementation the encapsulation principles let's use a special *\"Message Service\"*, because many repositories may contain similar method \"checkReponse()\".\r\n\r\n```javascript\r\n\r\n// Code in repository.\r\nfunction update(id){\r\n  webApi.updateFoodById({\r\n    \"url\": { \"id\": id } \r\n  }).success(function(response){\r\n    messageService.checkResponse(response, \"Updated!\");\r\n  });\r\n}\r\n\r\n// Code in some service.\r\nthis.checkResponse = function(response, message) {\r\n  // Internal implementation.\r\n}\r\n\r\n```\r\n\r\n### 18. Useful links.\r\n\r\n* https://github.com/asduser/webApi-angularjs - webApi RESTful module. *Powerful and flexible tool to work with $http*.\r\n* https://github.com/asduser/form-validator - html forms validator. *A special directive which provides functionality to work with html forms*.\r\n* https://github.com/asduser/ui-notifications - notifcication service. *Handles a different UI messages*.\r\n* https://github.com/asduser/storage-manager-anguarljs - storage manager. *Service to manage data storages on UI-side*.\r\n* https://github.com/asduser/grunt-automation-example - grunt automation tool. *How to set up task manager to simplify the process of development Angular.js project*.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}